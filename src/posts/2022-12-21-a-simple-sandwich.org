---
title: A Simple Sandwich
desc: "Correspondence with Danny Fekete"
image: "./images/blog/pumpkin_pie.jpg"
imageAlt: "drawing of pumpkin pie"
---

This is a correspondence(?) with Danny Fekete. Please read his [[https://neckdeep.dev/blog/2022-12-13-a-simple-sandwich-i/][post]] before reading this for context.

* Food for thought

The point of the exercise portrayed in the video is to explain to kids (or any non-programmers) what it's like to write a computer program to solve a task. I used to think this was an accurate analogy/explanation, but now I'm not so sure. It's being said that giving computer instructions to solve a task is challenging because you need to be very precise. The computer is dumb and won't fill in the gaps. It's not going to necessarily do the thing you have in mind if you give it vague instructions. Instead, it does the wrong thing or produces an error. So let's think about this. Why is it different from giving a human vague instructions? They can fill in the blanks. Why? It's because they have the same context as the instruction-giver and both of their minds are abstracting the details. If a human did not have the right context, they would do the task wrong like the dad in the video is showing as a joke. So, the dad is not acting like a computer, but rather a receiver that has improper context *and* is attempting the task anyway. Realistically, if a computer has improper context to perform an instruction, it will produce an error rather than try to do it and fail. In whatever programming language you choose, if you try to run the function "makeSandwich()" and that function doesn't exist, it will produce an error instead of try to make a sandwich (somehow...?).

So really what we're talking about here is *context* and *abstraction*; not necessarily humans vs computers. Now you think I'm being pedantic. True, computers are usually the ones with less context and can't do abstraction on their own. But programmers are the ones deciding what context is needed! If a language is made at a higher level of abstraction than another, it may need less context to accomplish the same task as the other. For example, in Haskell I can write ~putStrLn (unwords ["Hello", "world!"])~, but in C I would have to write a lot more code (giving more context about how to make an array into a sentence of words). The fact is, no programmer writes code *from scratch*. Everyone is building upon other work; even if you're only including the language's standard library.

In the end, if someone (it doesn't matter who) has made a ~makeSandwich~ function (and it makes a sandwich somehow...), I can tell the computer to run that function and I don't need to give it extra information. The same as a human.

Here's another thought. Less about being a programmer and more about giving instructions to a computer. The argument that computers need more detailed instructions than a human isn't even true anymore! Check out ChatGPT. It's a demonstration of a very powerful generalized artificial intelligence that can do spoken language processing that appears to be on par with humans. I can give it a problem to solve, written in plain English, and it will give a solution! Now the dad looks like he's just mocking old, primitive computers.

* Programming a sandwich

All the above being said, let's say we want to demonstrate what it would be like to program the computer to make a sandwich anyway. Danny wrote a great, complete example in Ruby code. After reading through it, it brings up lots of interesting points to talk about:

- Error handling
- Mutability and state
- Programming paradigms (OOP, functional)
- Type theory

Fortunately for me, Danny already handled the hardest part: deciding what functionality to include in sandwich-making code. After all, we can't expect the computer to make a real sandwich in the end, so one has to decide what a working solution entails.

For my own take on the problem [what exactly is the problem?], I decided to take the following steps:

- Translate Danny's OOP solution into Haskell
- Write an idiomatic Haskell solution
- Write a Haskell solution using type-level programming
- Write an Agda solution

* Error handling

Deciding how to handle errors is a notoriously difficult problem in programming. Before I could write any Haskell solution to the sandwich problem, I had to decide how I would handle errors. After all, there are many things that can go wrong along the way (like attempting to put a knife in a closed jar of peanut butter). Because Haskell is a purely functional language, every function is considered either to be "pure" or in a monad (such as "IO"). Using the concept of a monad is how Haskell gets around the "impure"/side-effect capability while retaining a pure mathematical foundation.

One option is to simply break execution and print an error message whenever one happens. In Haskell, this would be done using the built-in ~error~ function. But this comes with caveats:

- We can't know which functions may produce an error by looking at their type signature
- We can't recover from errors

Another option is to throw exceptions. Then we can catch errors, but it comes with a big caveat:

- Every function that may throw an exception (or include another function that may throw an exception) must be in the IO monad. This means virtually all the code has to live in the IO monad and we don't have any pure functions

A more idiomatic option in Haskell is to use the ~Maybe~ type. Any function that might produce an error returns a ~Maybe a~ value, which is either ~Nothing~ or ~Just a~, where ~a~ is any type. For example,

#+begin_src haskell
relinquishContents :: Jar -> Maybe (Jar, Condiment)
#+end_src

This version of ~relinquishContents~ takes a ~Jar~ and returns either ~Nothing~ if it fails (because the jar is closed or empty) or a pair ~(Jar, Condiment)~ of a new empty ~Jar~ and a ~Condiment~. The problem with ~Maybe~ is we don't have any sort of message attached to the error side; we just have ~Nothing~. So we know something went wrong, but we don't know what it is.

Finally, the solution I settled on is the other idiomatic option in Haskell: the ~Either~ type. It's almost the same as ~Maybe~ except it has ~Left a~ and ~Right b~, where ~a~ and ~b~ are any types. This way, we have,

#+begin_src haskell
relinquishContents :: Jar -> Either String (Jar, Condiment)
#+end_src

In the error case, ~relinquishContents~ returns a ~Left String~ (such as ~Left "The jar is closed and knife-impermeable."~). In the good case, it returns a ~Right (Jar, Condiment)~. In other words, we *either* have an error message or a good return value.

This means that every function that might produce an error must return an ~Either~ type, which allows us to keep most of the code pure. This also means we have no choice but to write code which handles the errors where they may occur. We can't simply skip over the fact that a function may produce an error; we have to handle both sides of the result: ~Left~ and ~Right~.

* Mutability and state

In OOP, it's common to make an instance of an object which has some properties, and then mutate those properties along the way. For example, we may have a ~CondimentJar~ with a ~contents~ property which start off as some string like "Peanut Butter". When we want to empty the jar, we set its ~contents~ property to ~nil~, effectively *mutating the state* of the jar.

In pure functional code, there's no such thing as mutability. When we have a ~CondimentJar~ with ~contents~ set to "Peanut Butter", we can't simply change that jar. It will always have "Peanut Butter" as its contents. Instead of mutating the jar's state, we can make a new jar which is a copy of the first one, but with its ~contents~ set to a different value.

To people less familiar with the concept of immutability, this may seem like a burden, and sometimes it can be! Really, it's just a different perspective on writing code. Instead of keeping track of every variable and its current state at any point in the code, immutability ensures that no variables can ever change and so we can easily predict their value.

Now, this presents us with a philosophical problem in the sandwich context. What sense does it make to have a jar which is always full of peanut butter and a knife which is always clean, and when we put them to use we have a *new* empty jar and a *new* loaded knife. Does it make sense that we still have access to the old objects? The way I see it, we can think of this in different ways.

In one way, we can say we simply don't care that it doesn't represent the real world accurately and as long as we don't make use of the old objects after we use them, we're not doing anything we couldn't do in reality. We just have to make sure to always use the latest version of each object.

Another way to think about it is that having access to the old objects is like being able to travel through time. We can think of every variable as being in a particular snapshot of the universe, which we can always go back to. However, this idea breaks down when we're able to access both a new object and its older counterpart at the same time, which is kind of like having multiple universes which can interact (Marvel anyone...?).

The most accurate representation of state in a pure functional context is to keep all stateful things in a variable which must be passed as an argument to any function which may update state. This is like passing around the universe (or at least, the important things) so we only have access to one version of it at any point in time. In Haskell, there are [[https://hackage.haskell.org/package/base-4.17.0.0/docs/Control-Concurrent-MVar.html][libraries]] which handle this in a monad. Then we can write code which looks like we're updating state, but anything that involves state must be inside the state monad.

In my code, I opted for the first approach; simply ignore the problem! The code is simpler to understand that way.

* Haskell - OOP translation

Since Haskell is a functional language, the following Haskell code is *not idiomatic*. It is a translation of the object-oriented Ruby solution. Similarly to how we might translate a poem from Portuguese to English word-for-word. The result may have proper grammar and spelling, but the English translation won't read much like a poem would have if it were written in English from the start.

** Condiment.hs

#+begin_src haskell
module Condiment where

type Condiment = String

data OpenOrClosed = Open | Closed
  deriving (Eq)

data Jar = Jar
  { contents :: Maybe Condiment
  , lid :: OpenOrClosed
  }

newJar :: Condiment -> Jar
newJar c = Jar
  { contents = Just c
  , lid = Closed
  }

isEmpty :: Jar -> Bool
isEmpty Jar{contents=Nothing} = True
isEmpty _ = False

hasStuff :: Jar -> Bool
hasStuff = not . isEmpty

isClosed :: Jar -> Bool
isClosed Jar{lid=Closed} = True
isClosed _ = False

closeJar :: Jar -> Jar
closeJar cj = cj {lid=Closed}

isOpen :: Jar -> Bool
isOpen = not . isClosed

openJar :: Jar -> Jar
openJar cj = cj {lid=Open}

relinquishContents :: Jar -> Either String (Jar, Condiment)
relinquishContents cj@Jar{contents=Just c}
  | isClosed cj = Left "The jar is closed and knife-impermeable."
  | isEmpty cj = Left "The jar is empty. How disappointing."
  | otherwise = Right (cj{contents=Nothing}, c)
#+end_src

Here, the ~newJar~ function acts in parallel to an object constructor in OOP (e.g., Ruby's ~initialize~ method).

#+begin_src haskell
-- Haskell
let pb = Condiment.newJar "Peanut Butter"
#+end_src

#+begin_src ruby
# Ruby
pb = CondimentJar.new("Peanut Butter")
#+end_src

For the OOP translation, a Haskell record is defined for each class in its Ruby counterpart. In idiomatic Haskell, records are used frequently, but not in such a way. And the small functions like ~isClosed~, which correspond to OOP methods, would be replaced by pattern matching.

As stated above about error handling, ~relinquishContents~ returns an ~Either~ type which may either be an error message (~Left String~) or a pair of a new empty jar and a condiment (~Right (Jar, Condiment)~).

** Knife.hs

#+begin_src haskell
module Knife where

import qualified Condiment

data Knife = Knife
  { contents :: Maybe Condiment.Condiment
  }

new :: Knife
new = Knife {contents=Nothing}

isClean :: Knife -> Bool
isClean Knife {contents=Nothing} = True
isClean _ = False

clean :: Knife -> Knife
clean k = k {contents=Nothing}

isLoaded :: Knife -> Bool
isLoaded = not . isClean

loadFrom :: Knife -> Condiment.Jar -> Either String (Knife, Condiment.Jar)
loadFrom k cj
  | isLoaded k = Left "This knife is already loaded. Don't mix your condiments!"
  | otherwise = uncurry load <$> Condiment.relinquishContents cj
  where
    load cj' c = (k {contents=Just c}, cj')
#+end_src

Interesting to note here is the decision to include ~loadFrom~ in the Knife.hs module. It seemed right to put it here because the OOP version has ~loadFrom~ as a method of the ~Knife~ object. But in this Haskell version, ~loadFrom~ is a function that happens to take a ~Knife~ and a ~Condiment.Jar~ as two arguments, so it doesn't need to belong in any specific module. It would work just as well to put it in Main.hs.

** Bread.hs

#+begin_src haskell
module Bread where

import qualified Condiment
import qualified Knife

data Surface = Surface
  { contents :: Maybe Condiment.Condiment
  }

newSurface :: Surface
newSurface = Surface
  { contents = Nothing
  }

surfaceIsPlain :: Surface -> Bool
surfaceIsPlain Surface {contents=Nothing} = True
surfaceIsPlain _ = False

surfaceIsSmeared :: Surface -> Bool
surfaceIsSmeared = not . surfaceIsPlain

data Slice = Slice
  { top :: Surface
  , bottom :: Surface
  }

newSlice :: Slice
newSlice = Slice
  { top = newSurface
  , bottom = newSurface
  }

sliceIsPlain :: Slice -> Bool
sliceIsPlain Slice {top=t, bottom=b}
  = surfaceIsPlain t && surfaceIsPlain b

sliceIsSmeared :: Slice -> Bool
sliceIsSmeared = not . sliceIsPlain

smearSurface :: Knife.Knife -> Surface -> Either String (Knife.Knife, Surface)
smearSurface k s
  | surfaceIsSmeared s = Left "This surface was already smeared!"
  | Knife.isClean k = Left "This knife is too clean to smear with."
  | otherwise = Right (Knife.clean k, s {contents=Knife.contents k})
#+end_src

** Sandwich.hs

#+begin_src haskell
module Sandwich where

import qualified Bread
import qualified Condiment
import qualified Knife

import qualified Data.Maybe as Maybe
import qualified Data.List as L

data Sandwich = Sandwich
  { slices :: [Bread.Slice]
  , built :: Bool
  , isCut :: Bool
  }

new :: [Bread.Slice] -> Sandwich
new slices = Sandwich
  { slices = slices
  , built = False
  , isCut = False
  }

flavours :: Sandwich -> [Condiment.Condiment]
flavours = concat . map sliceFlavours . slices
  where
    sliceFlavours :: Bread.Slice -> [Condiment.Condiment]
    sliceFlavours = Maybe.catMaybes . map Bread.contents . sequence [Bread.top, Bread.bottom]

showFlavours :: Sandwich -> String
showFlavours = f . flavours
  where
    f :: [Condiment.Condiment] -> String
    f cs
      | length cs == 2 = L.intercalate " and " cs
      | otherwise = L.intercalate ", " (init cs) ++ ", and " ++ last cs

isReadyToEat :: Sandwich -> Bool
isReadyToEat sw = built sw && isCut sw

build :: Sandwich -> Either String Sandwich
build sw
  | built sw = Left "It's already a glorious tower of food!"
  | length (slices sw) < 2 = Left "Not enough slices"
  | outsideSmeared = Left "This sandwich would be icky to hold."
  | tooPlain = Left "This sandwich might actually be a loaf."
  | otherwise = Right (sw {built=True})
  where
    bottomSmeared :: Bool
    bottomSmeared = Bread.surfaceIsSmeared . Bread.bottom . head $ slices sw
    
    topSmeared :: Bool
    topSmeared = Bread.surfaceIsSmeared . Bread.top . last $ slices sw
    
    outsideSmeared :: Bool
    outsideSmeared = length (slices sw) >= 2 && (bottomSmeared || topSmeared)

    tooPlain :: Bool
    tooPlain = any Bread.sliceIsPlain . init . tail $ slices sw

cut :: Sandwich -> Knife.Knife -> Either String Sandwich
cut sw k
  | (not . built) sw = Left "Build the sandwich and then cut it in one glorious stroke."
  | Knife.isLoaded k = Left "No! You'll get the edge all yucky with that knife."
  | isCut sw = Left "One cut will do."
  | otherwise = Right (sw {isCut=True})
#+end_src

** Main.hs

#+begin_src haskell
module Main where

import qualified Condiment
import qualified Knife
import qualified Bread
import qualified Sandwich

main :: IO ()
main = do
  let bread = replicate 5 Bread.newSlice
  let pb = Condiment.newJar "Peanut Butter"
  let jelly = Condiment.newJar "Jelly"
  let knife = Knife.new

  -- First attempt. Didn't open the jar of peanut butter.
  either (\e -> putStrLn $ "Error: " ++ e) putStrLn $ do
    (pbKnife, pbEmpty) <- knife `Knife.loadFrom` pb -- Problem
    (usedKnife1, surface1) <- Bread.smearSurface pbKnife . Bread.top . head $ bread
    (jellyKnife, jellyEmpty) <- knife `Knife.loadFrom` Condiment.openJar jelly
    (usedKnife2, surface2) <- Bread.smearSurface jellyKnife . Bread.bottom . last $ bread
    let sw = Sandwich.new bread
    Sandwich.build sw
    return "Sandwich made!"

  -- Next attempt. Used too much bread inside.
  either (\e -> putStrLn $ "Error: " ++ e) putStrLn $ do
    (pbKnife, pbEmpty) <- knife `Knife.loadFrom` Condiment.openJar pb
    (usedKnife1, surface1) <- Bread.smearSurface pbKnife . Bread.top . head $ bread
    (jellyKnife, jellyEmpty) <- knife `Knife.loadFrom` Condiment.openJar jelly
    (usedKnife2, surface2) <- Bread.smearSurface jellyKnife . Bread.bottom . last $ bread
    let sw = Sandwich.new bread
    Sandwich.build sw -- Problem
    return "Sandwich made!"

  -- Successful sandwich making!
  either (\e -> putStrLn $ "Error: " ++ e) putStrLn $ do
    (pbKnife, pbEmpty) <- knife `Knife.loadFrom` Condiment.openJar pb
    (usedKnife1, surface1) <- Bread.smearSurface pbKnife . Bread.top . head $ bread
    (jellyKnife, jellyEmpty) <- knife `Knife.loadFrom` Condiment.openJar jelly
    (usedKnife2, surface2) <- Bread.smearSurface jellyKnife . Bread.bottom . last $ bread
    let sw = Sandwich.new [head bread, last bread]
    Sandwich.build sw
    return "Sandwich made!"
#+end_src

* Haskell - idiomatic

** Main.hs

#+begin_src haskell
module Main where

data UtensilShape = Knife | Spoon | Fork
  deriving (Show, Eq)

data Utensil = Utensil
  { uShape :: UtensilShape
  , uCondiment :: Maybe Condiment
  }
  deriving (Show)

fetchUtensil :: UtensilShape -> Utensil
fetchUtensil shape = Utensil
  { uShape = shape
  , uCondiment = Nothing
  }

data Condiment = PeanutButter | Jelly
  deriving (Show, Eq)

data OpenOrClosed = Open | Closed
  deriving (Show, Eq)

data CondimentJar = CondimentJar
  { cjCondiment :: Maybe Condiment
  , cjLid :: OpenOrClosed
  }
  deriving (Show)

fetchCondimentJar :: Condiment -> CondimentJar
fetchCondimentJar c = CondimentJar
  { cjCondiment = Just c
  , cjLid = Closed
  }

loadFrom :: Utensil -> CondimentJar -> Either String (Utensil, CondimentJar)
loadFrom _ CondimentJar{cjLid=Closed} = Left "The jar is closed and knife-impermeable."
loadFrom _ CondimentJar{cjCondiment=Nothing} = Left "The jar is empty. How disappointing."
loadFrom Utensil{uShape=Fork} _ = Left "Forks aren't the right shape for condiments."
loadFrom u cj@CondimentJar{cjCondiment=Just c}
  = Right (u { uCondiment = Just c }, cj { cjCondiment = Nothing })

openJar :: CondimentJar -> CondimentJar
openJar cj = cj { cjLid = Open }

data BreadFlavour = Sourdough | WholeGrain | White
  deriving (Show)

data SliceOfBread = SliceOfBread
  { sobFlavour :: BreadFlavour
  , sobTop :: Maybe Condiment
  , sobBottom :: Maybe Condiment
  }
  deriving (Show)

fetchSliceOfBread :: BreadFlavour -> SliceOfBread
fetchSliceOfBread flavour = SliceOfBread
  { sobFlavour = flavour
  , sobTop = Nothing
  , sobBottom = Nothing
  }

data Surface = Top | Bottom
  deriving (Show, Eq)

smearSliceOfBread :: Utensil -> Surface -> SliceOfBread -> Either String (SliceOfBread, Utensil)
smearSliceOfBread u surface slice
  | uShape u /= Knife = Left "You can't smear with that!"
  | uCondiment u == Nothing = Left "This knife is too clean to smear with."
  | surface == Top && sobTop slice /= Nothing = Left "This surface was already smeared!"
  | surface == Bottom && sobBottom slice /= Nothing = Left "This surface was already smeared!"
  | otherwise = Right (smearedSlice, cleanUtensil)
  where
    smearedSlice
      | surface == Top = slice { sobTop = uCondiment u }
      | surface == Bottom = slice { sobBottom = uCondiment u }
    cleanUtensil = u { uCondiment = Nothing}

data Sandwich = Sandwich
  { swBottom :: SliceOfBread
  , swTop :: SliceOfBread
  , swPieces :: [(SliceOfBread, SliceOfBread)]
  }
  deriving (Show)

makeSandwich :: SliceOfBread -> SliceOfBread -> Either String Sandwich
makeSandwich bottom top
  | sobTop bottom == Nothing && sobBottom top == Nothing = Left "This sandwich might actually be a loaf."
  | sobTop top /= Nothing || sobBottom bottom /= Nothing = Left "This sandwich would be icky to hold."
  | otherwise = Right Sandwich { swBottom = bottom, swTop = top, swPieces = [(bottom, top)] }

-- A sandwich is always cut through all the pieces, doubling them all
cutSandwich :: Utensil -> Sandwich -> Either String Sandwich
cutSandwich u sw
  | uShape u == Fork || uShape u == Spoon = Left "You can't cut a sandwich with that!"
  | uCondiment u /= Nothing = Left "No! You'll get the edge all yucky with that knife."
  | otherwise = Right sw { swPieces = newPieces }
  where
    newPieces = concat [swPieces sw, swPieces sw]

main :: IO ()
main = do
  let knife = fetchUtensil Knife
  let pb = fetchCondimentJar PeanutButter
  let jelly = fetchCondimentJar Jelly

  -- First attempt. Didn't open the jar of peanut butter.
  either (\e -> putStrLn $ "Error: " ++ e) putStrLn $ do
    (pbKnife, emptyPB) <- knife `loadFrom` pb -- Problem
    return "Sandwich made!"

  -- Next attempt. Too plain.
  either (\e -> putStrLn $ "Error: " ++ e) putStrLn $ do
    (pbKnife, emptyPB) <- knife `loadFrom` openJar pb
    (jellyKnife, emptyJelly) <- knife `loadFrom` openJar jelly
    let bottomSlice = fetchSliceOfBread Sourdough
    let topSlice = fetchSliceOfBread WholeGrain
    sw <- makeSandwich bottomSlice topSlice
    return "Sandwich made!"

  -- Successful sandwich making!
  either (\e -> putStrLn $ "Error: " ++ e) putStrLn $ do
    (pbKnife, emptyPB) <- knife `loadFrom` openJar pb
    (jellyKnife, emptyJelly) <- knife `loadFrom` openJar jelly
    let bottomSlice = fetchSliceOfBread Sourdough
    let topSlice = fetchSliceOfBread WholeGrain
    (bottomSliceWithPB, cleanKnife) <- smearSliceOfBread pbKnife Top bottomSlice
    (topSliceWithJelly, cleanKnife) <- smearSliceOfBread jellyKnife Bottom topSlice
    sw <- makeSandwich bottomSliceWithPB topSliceWithJelly
    return "Sandwich made!"
#+end_src
