---
title: Genetic Algorithms in Plain English
desc: "An introduction to genetic algorithms with an example problem to solve."
image: "./images/blog/genetic_algorithm.jpg"
imageAlt: "Drawing of dna."
---

#+begin_center
/[[https://www.freepik.com/free-vector/dna-helix-symbol-isolated-white-background_24085108.htm#query=dna&position=0&from_view=search&track=sph][Image by brgfx]] on Freepik/
#+end_center

Years ago, I found [[http://www.ai-junkie.com/ga/intro/gat1.html][a tutorial]] on genetic algorithms that ended up being one of the most fun coding exercises I've ever done. It's a great way to practice with a new programming language you're learning, or improve with one you're already familiar with. I still think about it often and I wanted to write a tutorial of my own that I think is more approachable. So here it is!

* What is a genetic algorithm?

The origin of genetic algorithms is unclear, dating back to 1989[fn:2] or earlier[fn:1]. They are inspired by the process of natural selection and genetics, key parts of evolution. In this tutorial, I'm going to describe a basic genetic algorithm, which is easy to implement and also recommended by experts:

#+begin_quote
Start by using an "off the shelf" GA. It is pointless developing a complex GA, if your problem can be solved using a simple and standard implementation.

-- Sastry, K., Goldberg, D., Kendall, G. (2005). Genetic Algorithms.[fn:3]
#+end_quote

** The key points of natural selection

- organism
- chromosome
- gene
- DNA (maybe?)
- allele
- nucleotide
- genotype (maybe?)
- phenotype

You've probably heard the phrase "[[https://en.wikipedia.org/wiki/Survival_of_the_fittest][survival of the fittest]]". It's a concise way of describing the mechanism of natural selection. Organisms in nature (as in, the world separate from human impact) tend to have a higher probability of being preserved and reproducing when they are more fit for their environment than competing organisms. This "fitness" is not necessarily a physical fitness, like being strong, but any trait that makes the organism better adapted for its environment.
  
Let's talk about natural selection, or at least what's relevant to genetic algorithms.

In short, natural selection is a process that 
  
We're going to distill natural selection to a few key points that will be relevant to genetic algorithms.

In genetic algorithms, a chromosome is supposed to contain all the parameters for a potential solution of the problem that the algorithm is trying to solve.

* Standard genetic algorithm

/[Image: UML activity diagram of genetic algorithm]/

These are the steps to a standard genetic algorithm you can apply to many problems.

** Step 1. Planning

The first step towards building your algorithm for a target problem is to plan how to represent genes and chromosomes, and how to evaluate the fitness of an organism.

Breaking it down from the top, each *organism* will only be made up of a single *chromosome*, so the two terms are essentially interchangeable.

Each *chromosome* is made up of *genes*. In order for the crossover step to work (explained later), all chromosomes should be the same length (i.e., contain the same number of genes).

Each *gene* is made up of *nucleotides*, which are equivalent to units of information. Each nucleotide will be represented by one *bit* (~0~ or ~1~), since this is the smallest piece of information on a computer.

Every gene should be the same length, which is determined by the number of possible *alleles* needed for the target problem. For example, if you choose genes to be 3 bits in length, that gives

#+begin_center
*(length of bit)^(length of gene) = 2^3 = 8*
#+end_center

different possible alleles.

Each organism should represent a potential solution to the operating problem, which is its *phenotype*. For instance, if a solution is to be an English word, then a gene may represent a letter (e.g., "d") and a chromosome will thus be a string of letters (e.g., "dwnlode"), possibly forming an English word. The string of letters would be the phenotype of a chromosome.

For whatever problem we want our algorithm to solve, we need to know what a good solution looks like. That means we need some way of knowing which organisms are better than others. Remember, every organism is a potential solution to the given problem. The idea here is to come up with a way to evaluate each organism and give it a *fitness* score (a decimal number will do). The higher the fitness score, the closer the organism is to an ideal solution. It's difficult to be more precise than this because the fitness evaluation varies a lot depending on the problem, so I'll give an example. Let's say the target problem is to find the best values for ~a~, ~b~, ~c~, and ~d~ in the equation ~a + 2b + 3c + 4d = 30~.[fn:4] Each organism's phenotype is its four numbers. The fitness evaluation could be:

#+begin_center
#+begin_example
1 / (abs((a + 2b + 3c + 4d) - 30) + 1)
#+end_example
#+end_center

Where ~abs~ gives the absolute value of a number. This evaluation function is designed to give a higher fitness score for better values, with 1 being a perfect fitness score. In math terms, the range is ~(0, 1]~.

So, an organism with the values ~a = 0~, ~b = 0~, ~c = 10~, ~d = 0~ would have fitness

#+begin_center
#+begin_example
1 / (((a + 2b + 3c + 4d) - 30) + 1)
= 1 / (((0 + 2(0) + 3(10) + 4(0)) - 30) + 1)
= 1 / (0 + 1)
= 1
#+end_example
#+end_center

Which is a perfect score! This makes sense, because these values perfectly satisfy the target equation.

** Step 2. Setting parameters

There are 4 parameters that can be set and tweaked. These affect how well the algorithm runs on the target problem. Once you've finished implementing your algorithm, these are the parameters you'll want to play with and see how it performs differently.

*** Population size

This is the number of organisms in the population for each generation. We'll call this parameter ~populationSize~.

A good population size to try is *50*.

*** Crossover rate

As pairs of organisms are selected for each new generation's population, they may be left the same (as copies) or combined to make two new ones (like breeding offspring). The crossover rate is the *probability* that each pair of selected organisms will be crossed over, which will be explained in step 4. We'll call this parameter ~crossoverRate~.

A good crossover rate to try is *0.6*.

*** Mutation rate

Every bit of information in every chromosome has a (low) chance to be mutated. Mutations can spark new traits that can then be spread to future generations, adding diversity to the population We'll call this parameter ~mutationRate~.

A good mutation rate to try is *0.05*.

*** Stopping condition

At some point, the genetic algorithm has to stop! Otherwise, you've created an infinite loop. The easiest stopping condition to implement is to set a limit on the *number of generations*. When the limit is reached, take the organism with the highest fitness from the last generation's population and you have a solution!

Alternately, you could let the stopping condition be a *fitness threshold*. When a organism's fitness meets the threshold, deem it the winner!

** Step 3. Create initial population

The first generation of organisms needs to come from somewhere. A good way to make the first population is to randomly generate every bit of information in every organism until you have the right number of organisms for the population size.

** Step 4. Fitness evaluation

Evaluate the fitness of every organism in the population and store this information for later retrieval.[fn:5]

** Step 5. Selection

The current population needs to be used to form a new population (the next generation). Essentially, we're going to take pairs of organisms from the current population and breed them to form offspring. Each pair will breed two offspring, and once we have enough offspring, they become the new population.

Instead of just selecting organisms at random, the probability that an organism is selected should be proportional to its fitness. After all, this is the purpose of organism fitness! It should be more likely for two high-performing organisms to be paired up for breeding. A good way to do this proportional selection is to use the *roulette wheel* strategy.

Let's say we have a population of 5 organisms:

#+begin_export html
<div class="table-container">
#+end_export
| Organism | Chromosome  | Fitness | Percent of population fitness |
|----------+-------------+---------+-------------------------------|
|        1 | ~0011 0110~ |    0.23 |                          9.9% |
|        2 | ~0001 1010~ |    0.68 |                         29.2% |
|        3 | ~1001 1011~ |     0.1 |                          4.3% |
|        4 | ~1010 0111~ |    0.95 |                         40.8% |
|        5 | ~0101 0010~ |    0.37 |                         15.9% |
#+begin_export html
</div>
#+end_export

(Don't pay much attention to the chromosome values in this example; I made them up randomly.)

At a casino, every segment of a roulette wheel is equal size. But our goal is to make a roulette wheel where the segments are proportional to their fitness:

#+begin_center
[[file:images/blog/genetic_algorithm/genetic_algorithm_roulette.png]]
#+end_center

Now when we spin the wheel to select an organism, it's obvious there will be a bigger chance to land on *organism 4* than any other organism.

To implement roulette wheel selection in code, this is what you need to do:

- (Your organisms must be kept in order. The way they're ordered doesn't matter, so long as the order doesn't change.)
- Calculate the total fitness of the population, ~totalFitness~ (sum the fitnesses of all organisms).
- Calculate the cumulative fitness of each organism. The cumulative fitness of an organism is its fitness plus the sum of the fitnesses of all the previous organisms.
- Generate a random number, ~r~, between 0 (excluding) and ~totalFitness~ (including).
- Find the first organism whose cumulative fitness is greater than or equal to ~r~.

For example, if we calculate the cumulative fitnesses:

#+begin_export html
<div class="table-container">
#+end_export
| Organism | Chromosome  | Fitness | Cumulative fitness |
|----------+-------------+---------+--------------------|
|        1 | ~0011 0110~ |    0.23 |               0.23 |
|        2 | ~0001 1010~ |    0.68 |               0.91 |
|        3 | ~1001 1011~ |     0.1 |               1.01 |
|        4 | ~1010 0111~ |    0.95 |               1.96 |
|        5 | ~0101 0010~ |    0.37 |               2.33 |
#+begin_export html
</div>
#+end_export

And if our random number ~r~ turns out to be 1.89, that means we select *organism 4*.

The overall goal of this step is to *select two organisms*, which will breed a pair of offspring.[fn:6]

** Step 6. Crossover

The offspring of the two selected organisms will either inherit a combination of their traits (genes from both parents) or be clones of the parents.[fn:7]

*[HERE]*

Generate random number, compare to crossover rate to see if we should perform a crossover or simply clone the parents.

To crossover two organisms, pick a random position less than the length of a chromosome and swap all the bits to the right in the first chromosome with all the bits to the right in the second chromosome.

/[Drawing of crossover]/

** Step _. Mutation

For each bit in the offspring:
Generate random number, compare to mutation rate to see if it should mutate or stay the same. To mutate, simply flip the bit (0 -> 1, or 1 -> 0).

** Step _. New population

Steps _ to _ (selection, crossover, and mutation) together form the breeding process. Each cycle forms 2 offspring. We need to repeat the cycle until we get enough offspring to form the new population. The old population won't be needed anymore (everything dies...).

** Step 6. Repeat steps 4-5 until the stopping condition is met

Steps 4 and 5 form the main loop of the algorithm. These need to be repeated until a winner can be declared, which is determined by the organism with the highest fitness when the stopping condition has been met. If the stopping condition is a limit on the number of generations, say 100, then the solution is the organism with the highest fitness after 100 generations.

** Step 7. Solution (best organism)

In the last population, pick the organism with the highest fitness. There's your solution!

** Notes

It's important to have a chance of crossover /not/ happening. Suppose we have two organisms, Alice and Bob, selected to be parents. Alice's fitness score is 99% and Bob's is 80%. If Alice and Bob are to produce offspring who inherit from both of them, the offspring are almost guaranteed to have a lower fitness than Alice's 99% because they will have many of their genes replaced which likely won't fit well with the rest of their genes. What would give a better chance at being left with an organism with close-to-ideal fitness is if Alice's offspring is an exact clone, and perhaps even mutates a bit in the right way.

* A target problem

As with anything in programming, you're not going to understand simply by reading. You need to try implementing a genetic algorithm for yourself. But first, you need the right kind of problem to solve. Lucky for you, I've got that part covered. In this section, I'm going to outline a problem that you can solve by coding a genetic algorithm yourself. I'm going to give you all the details you need so you can implement it in any programming language you want. In other words, I'm going to cover *step 1* (planning) and you have to do the rest.

*The problem:* given a target number, find a string of single-digit numbers and basic arithmetic operators that equals that number. For example, if the target number is ~10~, some solutions would be:

- ~5 + 5~
- ~5 * 2~
- ~5 + 5 + 1 - 1 + 9 * 1~

All of these equal 10 exactly, so they are all ideal matches. Of course, there are infinitely many possibilities for any target number, but our algorithm may not discover any of them in the limited time it has to run. So, the true goal of our genetic algorithm is to give us the best candidate after a certain number of generations.

** Step 1. Planning

Since a potential solution is to be a string of single-digit numbers and arithmetic operators, that is exactly what a chromosome should represent. (Keep in mind that an organism is a single chromosome, so we can substitute one word for the other.) The genes, being pieces of a chromosome, should therefore each represent a single-digit number or an arithmetic operator.

To determine the gene length, we need to know how many possible alleles we need to represent. In this case, the possible alleles are all the single-digit numbers and arithmetic operators: ~0~, ~1~, ~2~, ~3~, ~4~, ~5~, ~6~, ~7~, ~8~, ~9~, ~+~, ~-~, ~*~, ~/~. 14 possible alleles in total means we need a minimum of 4 bits per gene, since that gives us 2^4 = 16 different possible alleles. We will have two left over alleles, but those can be ignored in the resulting chromosome. So, our possible genes are:

| gene   | allele    |
|--------+-----------|
| ~0000~ | ~0~       |
| ~0001~ | ~1~       |
| ~0010~ | ~2~       |
| ~0011~ | ~3~       |
| ~0100~ | ~4~       |
| ~0101~ | ~5~       |
| ~0110~ | ~6~       |
| ~0111~ | ~7~       |
| ~1000~ | ~8~       |
| ~1001~ | ~9~       |
| ~1010~ | ~+~       |
| ~1011~ | ~-~       |
| ~1100~ | ~*~       |
| ~1101~ | ~/~       |
| ~1110~ | ~nothing~ |
| ~1111~ | ~nothing~ |

/[gene_explanation.png -- Drawing of a single gene: circle nucleotide, circle gene, circle allele]/

Now we need to determine how the fitness of an organism (chromosome) should be evaluated. Recall that that we need an

* Food for thought

In the target problem described above, what are the traits of an organism? Does each organism have a single trait: its evaluated number? Or can we think of each gene as a trait?

Does crossing over two high-fitness organisms have a good chance of producing high-fitness offspring? Swapping genes seems likely to drastically change a chromosome's evaluated number, and not towards a better fitness.

* Footnotes

[fn:1] https://en.wikipedia.org/wiki/Genetic_algorithm#History
[fn:2] Goldberg, David (1989). Genetic Algorithms in Search, Optimization and Machine Learning. Reading, MA: Addison-Wesley Professional. ISBN 978-0201157673.
[fn:3] Sastry, K., Goldberg, D., Kendall, G. (2005). Genetic Algorithms. In: Burke, E.K., Kendall, G. (eds) Search Methodologies. Springer, Boston, MA. https://doi.org/10.1007/0-387-28356-0_4
[fn:4] Hermawanto, D. (2013). Genetic algorithm for solving simple mathematical equality problem. arXiv preprint [[https://arxiv.org/pdf/1308.4675.pdf][arXiv:1308.4675]].
[fn:5] This is arguably an implementation detail pertaining to optimization via caching, but I see it as having conceptual importance. The fitness of an organism never changes because its genetics don't change. This is different from how we might talk about people's physical fitness, where you can become more fit by working out. In evolution, fitness is tied to the genetics of an organism, which are fixed. The only changes to genetics happen between generations (i.e., during breeding). So, with fitness being an unchanging value of an organism, it should be evaluated exactly once per organism.
[fn:6] Note that this allows for the same organism to be selected more than once. That's okay! Organisms with higher fitness being allowed to breed multiple times is part of natural selection. Less fit individuals may not be selected to breed at all, allowing their less desirable traits to simply die out.
[fn:7] What does it mean for the offspring to be clones of the parents? Are we simulating an organism that breeds reproduces both sexually /and/ asexually? Or are we representing organisms that simply carry on living into the next generation?
